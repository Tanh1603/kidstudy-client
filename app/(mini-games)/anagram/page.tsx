// app/(mini-games)/anagram/page.tsx
"use client";

import { useAuth } from "@clerk/nextjs";
import { useState, useEffect, useCallback } from "react";
// Import Game component and its types. GameType is no longer directly exported by anagram.tsx
import Game, { GameWordData, AnagramRawQuestion } from "./anagram";
import Loading from "@/components/loading";
import DifficultySelector from "@/components/difficulty-selector";
import TopicSelector from "@/components/topic-selector";
// Import GameTypeEnum along with DifficultyEnum from your models file
import { DifficultyEnum, GameTypeEnum } from "@/app/models/Game"; // <--- Import GameTypeEnum here

const scrambleWord = (word: string): string => {
  const a = word.split("");
  for (let i = a.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [a[i], a[j]] = [a[j], a[i]];
  }
  return a.join("");
};

// --- Simulate raw data fetched from your database for Anagrams ---
// This data now adheres to the AnagramRawQuestion structure.
// Note: 'id' is NOT included here as it's typically auto-generated by the DB
// and we're generating a new one for React keys.
// The `difficulty` and `topicId` are part of each question here.
const ALL_ANAGRAM_RAW_QUESTIONS: AnagramRawQuestion[] = [
  // Animals Topic (id: 1)
  { word: "CAT", imageSrc: "/animation/cat.jpg", topicId: 1, difficulty: DifficultyEnum.EASY },
  { word: "DOG", imageSrc: "/animation/dog.jpg", topicId: 1, difficulty: DifficultyEnum.EASY },
  { word: "LION", imageSrc: "/animation/lion.jpg", topicId: 1, difficulty: DifficultyEnum.MEDIUM },
  { word: "TIGER", imageSrc: "/animation/tiger.jpg", topicId: 1, difficulty: DifficultyEnum.MEDIUM },
  { word: "ELEPHANT", imageSrc: "/animation/elephant.jpg", topicId: 1, difficulty: DifficultyEnum.HARD },
  { word: "RHINOCEROS", imageSrc: "/animation/rhinoceros.jpg", topicId: 1, difficulty: DifficultyEnum.HARD },

  // Objects Topic (id: 2)
  { word: "SUN", imageSrc: "/animation/sun.jpg", topicId: 2, difficulty: DifficultyEnum.EASY },
  { word: "FLOWER", imageSrc: "/animation/flower.jpg", topicId: 2, difficulty: DifficultyEnum.MEDIUM },
  { word: "COMPUTER", imageSrc: "/animation/computer.jpg", topicId: 2, difficulty: DifficultyEnum.MEDIUM },
  { word: "KEYBOARD", imageSrc: "/animation/keyboard.jpg", topicId: 2, difficulty: DifficultyEnum.HARD },
  { word: "TELEVISION", imageSrc: "/animation/television.jpg", topicId: 2, difficulty: DifficultyEnum.HARD },
  { word: "REFRIGERATOR", imageSrc: "/animation/refrigerator.jpg", topicId: 2, difficulty: DifficultyEnum.HARD },
  { word: "CHAIR", imageSrc: "/animation/chair.jpg", topicId: 2, difficulty: DifficultyEnum.EASY },
];

// --- Main Anagram Component ---
const Anagram = () => {
  const { userId, getToken } = useAuth();
  const [loading, setLoading] = useState(true);
  const [selectedDifficulty, setSelectedDifficulty] = useState<DifficultyEnum | null>(null);
  const [selectedTopicId, setSelectedTopicId] = useState<number | null>(null);
  const [gameWords, setGameWords] = useState<GameWordData[]>([]);

  useEffect(() => {
    const fetchAuthToken = async () => {
      setLoading(true);
      try {
        const token = await getToken();
        // console.log("Authentication token:", token);
      } catch (error) {
        console.error("Failed to retrieve authentication token:", error);
      } finally {
        setLoading(false);
      }
    };
    void fetchAuthToken();
  }, [userId, getToken]);

  // Function to get unique topics from the raw question data
  const getAvailableTopics = useCallback(() => {
    const topicsMap = new Map<number, { id: number; name: string }>();
    ALL_ANAGRAM_RAW_QUESTIONS.forEach(q => {
      // You'd ideally fetch topic names from a separate topics table.
      // For now, we'll assign a placeholder name based on topicId.
      // In a real app, you'd have a topics array like:
      // const TOPICS = [{ id: 1, name: "Animals" }, { id: 2, name: "Objects" }];
      // And then map q.topicId to TOPICS.find(t => t.id === q.topicId).name
      if (!topicsMap.has(q.topicId)) {
        let topicName = `Topic ${q.topicId}`; // Fallback name
        if (q.topicId === 1) topicName = "Animals";
        if (q.topicId === 2) topicName = "Objects";
        topicsMap.set(q.topicId, { id: q.topicId, name: topicName });
      }
    });
    return Array.from(topicsMap.values());
  }, []);

  // Function to filter and prepare words based on selected difficulty AND topic
  const getFilteredAndPreparedWords = useCallback((difficulty: DifficultyEnum, topicId: number): GameWordData[] => {
    // Filter by topic first
    const questionsForTopic = ALL_ANAGRAM_RAW_QUESTIONS.filter(q => q.topicId === topicId);

    let filteredByDifficulty: AnagramRawQuestion[] = [];
    switch (difficulty) {
      case DifficultyEnum.EASY:
        filteredByDifficulty = questionsForTopic.filter(q => q.difficulty === DifficultyEnum.EASY);
        break;
      case DifficultyEnum.MEDIUM:
        filteredByDifficulty = questionsForTopic.filter(q => q.difficulty === DifficultyEnum.MEDIUM);
        break;
      case DifficultyEnum.HARD:
        filteredByDifficulty = questionsForTopic.filter(q => q.difficulty === DifficultyEnum.HARD);
        break;
      default:
        // This case should ideally not be hit if DifficultyEnum is strictly used
        filteredByDifficulty = questionsForTopic;
    }

    // Map to GameWordData, adding 'letters' and a unique 'id'
    return filteredByDifficulty.map((data, index) => ({
      word: data.word,
      imageSrc: data.imageSrc,
      letters: scrambleWord(data.word), // Scramble the word to get the initial letters
      id: `${data.word}-${data.topicId}-${data.difficulty}-${index}`, // More robust ID
    }));
  }, []);

  const handleDifficultySelect = useCallback((difficulty: DifficultyEnum) => {
    setSelectedDifficulty(difficulty);
    setSelectedTopicId(null); // Reset topic selection when difficulty changes
    setGameWords([]); // Clear game words
  }, []);

  const handleTopicSelect = useCallback((topicId: number) => {
    if (selectedDifficulty === null) {
        console.error("Difficulty not selected before topic.");
        return;
    }
    setSelectedTopicId(topicId);
    const newGameWords = getFilteredAndPreparedWords(selectedDifficulty, topicId);
    setGameWords(newGameWords);
  }, [selectedDifficulty, getFilteredAndPreparedWords]);


  if (loading) return <Loading />;

  // --- Conditional Rendering Flow ---
  if (!selectedDifficulty) {
    return (
      <main className="flex min-h-screen items-center justify-center">
        <DifficultySelector onSelectDifficulty={handleDifficultySelect} />
      </main>
    );
  }

  if (!selectedTopicId) {
    const availableTopics = getAvailableTopics(); // Get topics based on your available data
    if (availableTopics.length === 0) {
      return (
        <main className="flex min-h-screen items-center justify-center text-white text-2xl">
          No topics available for anagrams.
        </main>
      );
    }
    return (
      <main className="flex min-h-screen items-center justify-center">
        <TopicSelector topics={availableTopics} onSelectTopic={handleTopicSelect} />
      </main>
    );
  }

  // Render the Game component only when both difficulty and topic are selected
  return (
    <main className="flex min-h-screen items-center justify-center">
      <Game
        topicId={selectedTopicId}
        difficulty={selectedDifficulty}
        gameType={GameTypeEnum.ANAGRAM} // Make sure GameType.ANAGRAM is correctly imported/defined
        words={gameWords}
      />
    </main>
  );
};

export default Anagram;
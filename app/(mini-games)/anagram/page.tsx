// app/(mini-games)/anagram/anagram.tsx
"use client"; // MUST be at the very top!

import { useState, useEffect, useCallback } from "react";
import Image from "next/image";
import { Button } from "@/components/ui/button";
import { motion, AnimatePresence, Reorder } from "framer-motion";
import { Header } from "@/components/ui/header-game";
import { AlertTriangle, Lightbulb } from "lucide-react";
import GameEndScreen from "./game-end-screen";
import { shuffleArray } from "@/lib/utils";
import { Footer } from "@/components/ui/footer-game";
import { z } from "zod";
// Import your Zod schema and inferred types
import {
  DifficultyEnum,
  GameTypeEnum,
  AnagramGameQuestion, // The inferred type from anagramSchema
  anagramSchema, // The schema itself
} from "@/app/models/Game"; // Adjust path if necessary

// --- Define Internal Component Types ---
// This type represents the data for a single word within the Anagram game,
// after it's been processed and prepared for the UI (e.g., letters scrambled, id generated).
export type GameWordData = {
  id: string; // Unique ID for React keys, generated by the component
  word: string; // The correct word
  imageSrc: string; // The image source
  letters: string; // The scrambled letters
};

// --- Game Props ---
// Now, the 'words' prop expects an array of AnagramGameQuestion
interface GameProps {
  words: AnagramGameQuestion[]; // Expect array of validated anagram questions
}

const MAX_INCORRECT_ATTEMPTS = 5;

const Game = ({ words: initialValidatedWordsData }: GameProps) => {
  // --- Data Validation at the entry point ---
  // Parse (validate) the incoming data using the Zod schema
  let parsedWords: AnagramGameQuestion[];
  try {
    // We expect an array of AnagramGameQuestion, so we create a schema for an array of them.
    const wordsArraySchema = z.array(anagramSchema);
    parsedWords = wordsArraySchema.parse(initialValidatedWordsData);

    // Filter out any entries that might not be valid after parsing (though Zod should catch most)
    // and ensure we have actual words.
    if (!parsedWords || parsedWords.length === 0) {
        throw new Error("No valid anagram words provided.");
    }
  } catch (error) {
    console.error("Anagram game data validation error:", error);
    // Render an error state if the data is malformed
    return (
      <div className="flex min-h-screen items-center justify-center text-red-500 text-2xl p-4 text-center">
        Error loading game data. Please check the data source.
        {/* For debugging, you might display more of the error: */}
        {/* <pre className="text-sm mt-4 text-gray-700">{JSON.stringify(error, null, 2)}</pre> */}
      </div>
    );
  }

  // --- Process Validated Data for Game State ---
  // Create the `typedWords` array which includes the scrambled letters and generated IDs.
  // This step is crucial because `AnagramGameQuestion` doesn't have `letters` or the UI `id`.
  const typedWords: GameWordData[] = parsedWords.map((wordData, index) => ({
    id: `${wordData.id}-${index}`, // Use backend ID + index for stable unique key
    word: wordData.word,
    imageSrc: wordData.imageSrc instanceof File ? URL.createObjectURL(wordData.imageSrc) : wordData.imageSrc, // Handle File objects
    letters: shuffleArray(wordData.word.split("")).join(""), // Scramble the word for display
  }));

  // Defensive check for processed words data
  if (typedWords.length === 0) {
    return (
      <div className="flex items-center justify-center min-h-screen text-2xl text-white">
        No words available for this difficulty!
      </div>
    );
  }

  // --- State Declarations (rest remain the same) ---
  const [currentWordIndex, setCurrentWordIndex] = useState(0);
  const [userAnswerLetters, setUserAnswerLetters] = useState<
    { letter: string; originalIndex: number; id: string }[]
  >([]);
  const [status, setStatus] = useState<"correct" | "wrong" | "none">("none");
  const [score, setScore] = useState(0);
  const [isGameOver, setIsGameOver] = useState(false);
  const [incorrect, setIncorrect] = useState(0);
  const [time, setTime] = useState(0);
  const [isRunning, setIsRunning] = useState(false);
  const [hasWon, setHasWon] = useState(false);

  // --- Derived State (currentWord now comes from typedWords) ---
  const currentWord = typedWords[currentWordIndex]; // Already processed and guaranteed to exist

  // --- Memoized Callbacks (useCallback) ---
  const initializeCurrentWordLetters = useCallback(() => {
    if (currentWord) {
      const initialLetters = currentWord.letters.split('').map((letter, index) => ({
        letter,
        originalIndex: index,
        id: `${currentWord.id}-letter-${index}-${letter}`, // More robust ID for letters
      }));
      setUserAnswerLetters(shuffleArray(initialLetters));
      setStatus("none");
    }
  }, [currentWord]); // Dependency on currentWord is correct here

  // handleSubmit remains largely the same, operating on currentWord
  const handleSubmit = useCallback(() => {
    const userWord = userAnswerLetters.map((item) => item.letter).join("");

    if (userWord === currentWord.word) { // currentWord is guaranteed to exist
      setStatus("correct");
      setScore((prevScore) => prevScore + 1);

      if (currentWordIndex === typedWords.length - 1) {
        setIsRunning(false);
        setHasWon(true);
        setIsGameOver(true);
      } else {
        setTimeout(() => {
          setCurrentWordIndex((prevIndex) => prevIndex + 1);
        }, 1000);
      }
    } else {
      setStatus("wrong");
      setIncorrect((prev) => {
        const newAttempt = prev + 1;
        if (newAttempt >= MAX_INCORRECT_ATTEMPTS) {
          setIsGameOver(true);
          setIsRunning(false);
        }
        return newAttempt;
      });
    }
  }, [userAnswerLetters, currentWord, currentWordIndex, typedWords.length]);

  const handleReset = useCallback(() => {
    initializeCurrentWordLetters();
  }, [initializeCurrentWordLetters]);

  const restartGame = useCallback(() => {
    setIsGameOver(false);
    setScore(0);
    setCurrentWordIndex(0);
    setIncorrect(0);
    setHasWon(false);
    setTime(0);
    setIsRunning(true);
  }, []);

  // --- Effects (useEffect) ---
  useEffect(() => {
    // Only initialize letters if game is not over and there's a current word
    if (!isGameOver && !hasWon && currentWord) {
      initializeCurrentWordLetters();
      if (currentWordIndex === 0 && !isRunning) { // Start timer only at the very beginning
        setTime(0);
        setIsRunning(true);
      }
    }
  }, [currentWordIndex, isGameOver, hasWon, initializeCurrentWordLetters, currentWord, isRunning]);


  useEffect(() => {
    let interval: NodeJS.Timeout | null = null;
    if (isRunning) {
      interval = setInterval(() => {
        setTime((prevTime) => prevTime + 1);
      }, 1000);
    } else if (!isRunning && interval) {
      clearInterval(interval);
    }
    return () => {
      if (interval) clearInterval(interval);
    };
  }, [isRunning]);

  useEffect(() => {
    const handleKeyPress = (event: KeyboardEvent) => {
      if (event.key === "Enter" && !isGameOver && !hasWon) {
        handleSubmit();
      }
    };

    window.addEventListener("keydown", handleKeyPress);
    return () => {
      window.removeEventListener("keydown", handleKeyPress);
    };
  }, [handleSubmit, isGameOver, hasWon]);

  // --- Main JSX (remains largely the same) ---
  return (
    <div
      className="flex flex-col items-center w-full min-h-screen relative"
      style={{
        backgroundImage: "url('/animation/anagram-bg.jpg')",
        backgroundPosition: "center",
        backgroundSize: "cover",
        backgroundRepeat: "no-repeat",
        backgroundAttachment: "fixed",
      }}
    >
      <div className="absolute inset-0 bg-black opacity-5 z-0"></div>

      <Header
        currentWordIndex={currentWordIndex}
        totalWords={typedWords.length}
      />

      <div className="relative z-10 flex flex-col items-center w-full flex-grow overflow-x-hidden">
        {isGameOver ? (
          <GameEndScreen
            score={score}
            time={time}
            onRestart={restartGame}
            hasWon={hasWon}
          />
        ) : (
          <>
            <div
              className="flex flex-col items-center flex-grow mx-auto w-fit min-w-[320px] md:min-w-[600px] max-w-full
                         px-4 py-4 md:px-6 md:py-6 lg:px-8 lg:py-8
                         md:flex-row justify-center gap-4 md:gap-6 lg:gap-8
                         mt-8 mb-8 p-4 md:p-6 rounded-xl shadow-2xl relative "
              style={{
                backgroundImage: "url('/animation/anagram-bg2.jpg')",
                backgroundPosition: "center",
                backgroundSize: "cover",
                backgroundRepeat: "no-repeat",
                backgroundAttachment: "local",
              }}
            >
              <div className="absolute inset-0 bg-white opacity-10 rounded-xl z-10"></div>

              <div className="relative z-20 flex flex-col items-center gap-3 order-first md:order-last flex-shrink">
                <div
                  className="relative w-full max-w-[200px] sm:max-w-[400px] md:max-w-[200px] lg:max-w-[250px]
                                 aspect-video mb-3 rounded-lg overflow-hidden"
                  style={{
                    backgroundImage: "url('/animation/timer-background.png')",
                    backgroundSize: "cover",
                    backgroundPosition: "center",
                    backgroundRepeat: "no-repeat"
                  }}
                >
                  <div className="absolute inset-0 flex items-center justify-center">
                    <div className="text-3xl sm:text-4xl lg:text-5xl font-bold font-mono text-white text-game-display">
                      {Math.floor(time / 60)}:{time % 60 < 10 ? `0${time % 60}` : time % 60}
                    </div>
                  </div>
                </div>

                <div className="text-2xl sm:text-3xl lg:text-4xl font-bold font-mono text-yellow-400 text-game-display mb-1">
                  Score
                </div>

                <div
                  className="relative w-full max-w-[200px] sm:max-w-[250px] md:max-w-[200px] lg:max-w-[250px]
                                 aspect-video mb-3 rounded-lg overflow-hidden"
                  style={{
                    backgroundImage: "url('/animation/score-board.png')",
                    backgroundSize: "contain",
                    backgroundPosition: "center",
                    backgroundRepeat: "no-repeat"
                  }}
                >
                  <div className="absolute inset-0 flex items-center justify-center">
                    <div className="text-3xl sm:text-4xl lg:text-5xl font-bold font-mono text-white text-game-display">
                      {score}
                    </div>
                  </div>
                </div>

                {(() => {
                  const attemptsLeft = MAX_INCORRECT_ATTEMPTS - incorrect;
                  let containerClasses = "flex items-center justify-center px-3 py-2 sm:px-4 sm:py-2 rounded-xl font-bold transition-colors duration-300 transform scale-100";
                  let textClasses = "text-sm sm:text-base md:text-lg";
                  let icon = null;
                  let iconClasses = "mr-1 h-4 w-4 sm:h-5 sm:w-5";

                  if (attemptsLeft <= 0) {
                    containerClasses += " bg-gray-200 border-gray-400 text-gray-600 border-2";
                    icon = <Lightbulb className={`${iconClasses} text-gray-500`} />;
                  } else if (attemptsLeft <= 2) {
                    containerClasses += " bg-red-100 border-red-400 text-red-700 border-2";
                    icon = <AlertTriangle className={`${iconClasses} text-red-600`} />;
                    if (attemptsLeft === 1) {
                      containerClasses += " animate-pulse-fast";
                    }
                  } else {
                    containerClasses += " bg-green-50 border-green-200 text-green-600 border-2";
                    icon = <Lightbulb className={`${iconClasses} text-green-500`} />;
                  }

                  return (
                    <motion.div
                      key={attemptsLeft}
                      initial={{ opacity: 0, y: -20, scale: 0.8 }}
                      animate={{ opacity: 1, y: 0, scale: 1 }}
                      transition={{ type: "spring", stiffness: 300, damping: 20 }}
                      className={`${containerClasses} ${textClasses}`}
                    >
                      {icon}
                      <span>You have {attemptsLeft} attempts left</span>
                    </motion.div>
                  );
                })()}
              </div>

              <div className="relative z-20 flex flex-col items-center order-last md:order-first flex-shrink">
                <div
                  className="mb-6 p-3 border-3 border-yellow-500 rounded-lg shadow-xl bg-white flex-shrink-0
                             w-full max-w-[300px] sm:max-w-[350px] md:max-w-[400px] lg:max-w-[450px]"
                >
                  <Image
                    key={currentWord.id} // Use the generated id for the key
                    src={currentWord.imageSrc}
                    alt={currentWord.word}
                    width={450}
                    height={337}
                    className="object-cover w-full h-auto"
                  />
                </div>

                <div className="w-full overflow-x-auto">
                  <AnimatePresence mode="wait" initial={false}>
                    <motion.div
                      initial={{ opacity: 0, scale: 0.8 }}
                      animate={{ opacity: 1, scale: 1 }}
                      exit={{ opacity: 0, scale: 0.8 }}
                      transition={{
                        type: "spring",
                        stiffness: 260,
                        damping: 20,
                      }}
                      className="w-full flex justify-center min-w-0"
                    >
                      <Reorder.Group
                        axis="x"
                        values={userAnswerLetters}
                        onReorder={setUserAnswerLetters}
                        className="flex flex-nowrap gap-1 sm:gap-2 mb-6 p-3 border-2 border-dashed border-gray-300 rounded-md justify-start items-center"
                      >
                        {userAnswerLetters.map((item) => (
                          <Reorder.Item
                            key={item.id}
                            value={item}
                            initial={{ opacity: 0, scale: 0.8 }}
                            animate={{ opacity: 1, scale: 1 }}
                            exit={{ opacity: 0, scale: 0.8 }}
                            transition={{ type: "spring", stiffness: 300, damping: 20 }}
                            className="w-8 h-8 text-base flex items-center justify-center font-bold cursor-grab flex-shrink-0
                                       sm:w-10 sm:h-10 sm:text-lg md:w-12 md:h-12 md:text-xl lg:w-14 lg:h-14 lg:text-2xl"
                            style={{ zIndex: 10 }}
                          >
                            <Button variant={"secondary"} className="text-white text-base sm:text-lg md:text-xl w-full h-full">
                              {item.letter}
                            </Button>
                          </Reorder.Item>
                        ))}
                      </Reorder.Group>
                    </motion.div>
                  </AnimatePresence>
                </div>

                <motion.div
                  initial={{ opacity: 0, scale: 0 }}
                  animate={{ opacity: 1, scale: 1 }}
                  transition={{
                    duration: 0.4,
                    scale: { type: "spring", visualDuration: 0.4, bounce: 0.5 },
                  }}
                  whileTap={{ scale: 0.9, rotate: 3 }}
                >
                  <Button
                    onClick={handleSubmit}
                    variant={"super"}
                    className="mb-4 text-lg sm:text-xl px-6 py-2 sm:px-8 sm:py-3"
                  >
                    Submit
                  </Button>
                </motion.div>

                <motion.div
                  initial={{ opacity: 0, scale: 0 }}
                  animate={{ opacity: 1, scale: 1 }}
                  transition={{
                    duration: 0.4,
                    scale: { type: "spring", visualDuration: 0.4, bounce: 0.5 },
                  }}
                  whileTap={{ scale: 0.9, rotate: 3 }}
                >
                  <Button onClick={handleReset} variant={"super"}
                    className="text-lg sm:text-xl px-6 py-2 sm:px-8 sm:py-3">
                    Reset
                  </Button>
                </motion.div>
              </div>
            </div>

            {status === "correct" && <div className="mt-3 text-lg sm:text-xl text-green-500 font-bold" aria-live="polite">Correct!</div>}
            {status === "wrong" && (
              <div className="mt-3 text-lg sm:text-xl text-red-500 font-bold" aria-live="polite">
                Try Again!
              </div>
            )}
          </>
        )}
      </div>

      <Footer />
    </div>
  );
};

export default Game;